---
title: "Appendix"
author: "Erika Y. Lin"
date: "2024-04-24"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, message = FALSE, warning = FALSE}

# Load requisite packages
library(ggplot2)  # data visualization
library(devtools)  # to load `mga` from GitHub
library(rphylopic)  # for icons
library(dplyr)  # for piping

# Install and load `mga` from GitHub
install_github("https://github.com/ErikaYLin/mga")
library(mga)

# Colour palettes
palette <- c("#005F73", "#0A9396", "#94D2BD", "#7A9EC6", "#E9D8A6", "#fbb13c",
             "#CA6702", "#9B2226", "#9F72AA", "#6d597a", "#355070")
palette2 <- c(environment(khroma::colour("light"))[["col_colors"]][c(1:5)],
              environment(khroma::colour("pale"))[["col_colors"]][3],
              environment(khroma::colour("light"))[["col_colors"]][c(5,4)])

```

## Sensitivity Analysis

A sensitivity analysis was conducted for the choice of reference libraries. We used Illumina Miseq 2x250 16S region amplicon data collected by Schloss et al. (2012) for a study investigating the stabilization of the murine microbiome after weaning. 

```{r bacteria1,  fig.cap = "Sequencing quality profiles for the first two forward sequencing read files, samples F3D0 and F3D1."}

# Import reference library FASTAs
## 16S silva reference FASTA with species
silva.138.1S <- "./vignettes/silva_nr99_v138.1_wSpecies_train_set.fa.gz"
## old 16S silva reference FASTA
silva.132 <- "./vignettes/silva_nr_v132_train_set.fa.gz" 
## 16S greengenes reference FASTA
GG.13.8 <- "./vignettes/gg_13_8_train_set_97.fa.gz" 

# Import sample metadata
meta <- read.csv("https://raw.githubusercontent.com/spholmes/F1000_workflow/master/data/MIMARKS_Data_combined.csv")

# Reformat sample names in metadata
meta$sample.ID <- paste0(gsub("00", "", meta$host_subject_id), "D", meta$age-21)
meta <- meta[!duplicated(meta$sample.ID),]  # Remove duplicate entries for reverse reads
meta <- meta[,-c(1:30,45,46)]  # Remove empty columns

# Define filter path for the forward and reverse reads of each sample fastq file
seq_path <- "./vignettes/MiSeq_SOP"  # directory for fastq file after unzipping folder

# Sort forward and reverse reads to be in the same order
fnFs <- sort(list.files(seq_path, pattern = "_R1_001.fastq"))
fnRs <- sort(list.files(seq_path, pattern = "_R2_001.fastq"))

# Remove "Mock" fastq files
fnFs <- fnFs[-20]
fnRs <- fnRs[-20]

# Specify the full path to files
fnFs <- file.path(seq_path, fnFs)
fnRs <- file.path(seq_path, fnRs)

# Extract sample names, assuming file paths have format:
# FOL_DER/SAMPLENAME_XXX.fastq.gz OR FOL_DER/SAMPLENAME_XXX.fastq
sNames <- sapply(strsplit(fnFs, "_"), `[`, 2)
sNames <- sapply(strsplit(sNames, "/"), `[`, 2)

# Inspect the first 2 forward reads:
dada2::plotQualityProfile(fnFs[1:2])
# forward reads maintain high throughput quality, trimmed at position 240

```

```{r bacteria1B, fig.cap = "Sequencing quality profiles for the first two reverse sequencing read files, samples F3D0 and F3D1."}

# Inspect the first 2 reverse reads:
dada2::plotQualityProfile(fnRs[1:2])
# reverse read quality drops at ~position 160, trimmed at position 160
# first 10 bps also removed due to potential pathological issues

# Define file names for filtered fastq.gz files and assign file paths
filt_path <- file.path(seq_path, "filtered")
# Place filtered files in new subdirectory if one does not already exist
if (!file_test("-d", filt_path)) dir.create(filt_path)
filtFs <- file.path(filt_path, paste0(sNames, "_F_filt.fastq.gz"))
filtRs <- file.path(filt_path, paste0(sNames, "_R_filt.fastq.gz"))

```

Based on the sequencing quality plots of the first two files, the quality of the forward sequence reads remains high, so these were trimmed at position 240, while reverse read quality decreased substantially around position 160, so these were trimmed at position 160. The first 10 base pairs were also trimmed from both forward and reverse reads, to avoid potential pathological issues. A maximum of two errors per read were allowed for the filtering and trimming process, and both forward and reverse reads in a pair must pass the criteria to be kept. 

```{r bacteria2, eval = FALSE}

# Filter and trim files based on the previous plots
out <- dada2::filterAndTrim(fnFs, filtFs, fnRs, filtRs,
                            truncLen = c(240,160),  # trim positions
                            maxN = 0,
                            maxEE = c(2,2), # 2 errors allowed
                            truncQ = 2,
                            rm.phix = TRUE,
                            compress = TRUE,
                            multithread = FALSE) # On Windows set multithread = FALSE

```

### `mga` Sequence Processing for Bacterial Data

Three separate reference FASTAs were used for the sensitivity analysis to check for differences between older and updated libraries for the same database and between different databases. The Silva and GreenGenes bacterial training FASTAs formatted for DADA2 are shown below. Due to the computation time, results were saved and imported for subsequent analyses.

**Silva NR v132 reference library:**

```{r silva132, eval = FALSE}

# Empty list for storing the results
SILVA.OLD <- list()

# Loop the analysis process for every file in the directory
for (i in 1:length(fnFs)){

  # Assign metadata to be input as a list
  meta_data <- list()
  for (j in 1:length(fnFs)){

    # Extract each file name
    ID <- sapply(strsplit(fnFs[i], "_"), `[`, 2)
    ID <- sapply(strsplit(ID, "/"), `[`, 2)
    # List the metadata for each pair of sequence reads
    meta_data[[j]] <- as.list(meta[meta$sample.ID %in% ID,])
  }

  # Create a new row of results for each output from `mga`
  SILVA.OLD[[i]] <- mga::mga(fastq.Fs = fnFs[i], # raw fastq files
                            fastq.Rs = fnRs[i], 
                            filtFs = filtFs[i], # filtered fastq files
                            filtRs = filtRs[i], 
                            refFasta = silva.132, # silva 132 ref FASTA
                            metadata = meta_data[[j]]) # additional meta data
}

# Extract sample results from the saved list
RES <- list()
for (i in 1:length(SILVA.OLD)){

  RES[[i]] <- SILVA.OLD[[i]]$results.samples
}

# Build combined data frame of metrics
results.df <- do.call(rbind, RES)
results.df <- dplyr::relocate(results.df, "sample.ID", .before = "Shannon") 
# move sample.ID column to leftmost

# Add additional metadata
meta2 <- read.delim(file = "vignettes/MiSeq_SOP/mouse.dpw.metadata")
results.df$dpw <- meta2$dpw
results.df$dpwgroup <- NA
results.df[results.df$dpw <= 9,]$dpwgroup <- "0-9"
results.df[results.df$dpw >= 141,]$dpwgroup <- "141-150"

```

**Silva NR99 v138.1 reference library:**

```{r silva138.1, eval = FALSE}

# Empty list for storing the results
SILVA.NEWS <- list()

# Loop the analysis process for every file in the directory
for (i in 1:length(fnFs)){

  # Assign metadata to be input as a list
  meta_data <- list()
  for (j in 1:length(fnFs)){

    # Extract each file name
    ID <- sapply(strsplit(fnFs[i], "_"), `[`, 2)
    ID <- sapply(strsplit(ID, "/"), `[`, 2)
    # List the metadata for each pair of sequence reads
    meta_data[[j]] <- as.list(meta[meta$sample.ID %in% ID,])
  }

  # Create a new row of results for each output from `mga`
  SILVA.NEWS[[i]] <- mga::mga(fastq.Fs = fnFs[i],
                             fastq.Rs = fnRs[i], 
                             filtFs = filtFs[i],
                             filtRs = filtRs[i], 
                             refFasta = silva.138.1S, # silva 138.1 ref FASTA
                             metadata = meta_data[[j]])
}

# Extract sample results from the saved list
RES2 <- list()
for (i in 1:length(SILVA.NEWS)){

  RES2[[i]] <- SILVA.NEWS[[i]]$results.samples
}

# Build combined data frame of metrics
results.df2 <- do.call(rbind, RES2)
results.df2 <- dplyr::relocate(results.df2, "sample.ID", .before = "Shannon") 
# move sample.ID column to leftmost

# Add additional metadata
results.df2$dpw <- meta2$dpw
results.df2$dpwgroup <- NA
results.df2[results.df2$dpw <= 9,]$dpwgroup <- "0-9"
results.df2[results.df2$dpw >= 141,]$dpwgroup <- "141-150"

```

**GreenGenes v13.8 reference library:**

```{r gg13.8, eval = FALSE}

# Empty list for storing the results
GREEN <- list()

# Loop the analysis process for every file in the directory
for (i in 1:length(fnFs)){

  # Assign metadata to be input as a list
  meta_data <- list()
  for (j in 1:length(fnFs)){

    # Extract each file name
    ID <- sapply(strsplit(fnFs[i], "_"), `[`, 2)
    ID <- sapply(strsplit(ID, "/"), `[`, 2)
    # List the metadata for each pair of sequence reads
    meta_data[[j]] <- as.list(meta[meta$sample.ID %in% ID,])
  }

  # Create a new row of results for each output from `mga`
  GREEN[[i]] <- mga::mga(fastq.Fs = fnFs[i],
                         fastq.Rs = fnRs[i],
                         filtFs = filtFs[i],
                         filtRs = filtRs[i], 
                         refFasta = GG.13.8, # greengenes ref FASTA
                         metadata = meta_data[[j]])
}

# Extract sample results from the saved list
RES4 <- list()
for (i in 1:length(GREEN)){

  RES4[[i]] <- GREEN[[i]]$results.samples
}

# Build combined data frame of metrics
results.df3 <- do.call(rbind, RES2)
results.df3 <- dplyr::relocate(results.df3, "sample.ID", .before = "Shannon") 
# move sample.ID column to leftmost

# Add additional metadata
results.df3$dpw <- meta2$dpw
results.df3$dpwgroup <- NA
results.df3[results.df3$dpw <= 9,]$dpwgroup <- "0-9"
results.df3[results.df3$dpw >= 141,]$dpwgroup <- "141-150"

```

As this process can take time, the outputs were saved as RDA and RDS files and reloaded for subsequent analyses. Computation time is proportional to the number of samples the function is looped over.

```{r inspect_mga}

# Load mga results and saved data frame
load(file = "vignettes/RDS/silva132_mga_results.rda")
results.df <- readRDS("vignettes/RDS/results.df_silva132_mga.rds")
load(file = "vignettes/RDS/silva138.1S_mga_results.rda")
results.df2 <- readRDS("vignettes/RDS/results.df_silva138.1S_mga.rds")
load(file = "vignettes/RDS/gg13.8_mga_results.rda")
results.df3 <- readRDS("vignettes/RDS/results.df_gg13.8_mga.rds")

# Inspect full mga outcomes
# silva NR v132
class(SILVA.OLD[[1]]) # each list item is a mga-class object
names(SILVA.OLD[[1]]) # outputs stored in each object

# Inspect `phyloseq` object
SILVA.NEWS[[1]]$ps

# Inspect resulting data frame of diversity and network measures
knitr::kable(head(results.df[,c(1:11)]),  # Results for silva NR v132
             caption = "Diversity measures and network diagnostics for the 
             first six samples in the mga-class object produced using the 
             Silva NR v132 reference library.")

# Inspect full mga outcomes
# silva NR99 v138.1
class(SILVA.NEWS[[1]]) # each list item is a mga-class object
names(SILVA.NEWS[[1]]) # outputs stored in each object

# Inspect resulting data frame of diversity and network measures
knitr::kable(head(results.df2[,c(1:11)]),  # Results for silva NR99 v138.1
             caption = "Diversity measures and network diagnostics for the 
             first six samples in the mga-class object produced using the 
             Silva NR99 v138.1 reference library.")

# Inspect full mga outcomes
# greengenes v13.8
class(GREEN[[1]]) # each list item is a mga-class object
names(GREEN[[1]]) # outputs stored in each object

# Inspect resulting data frame of diversity and network measures
knitr::kable(head(results.df3[,c(1:11)]),  # Results for greengenes v13.8
             caption = "Diversity measures and network diagnostics for the 
             first six samples in the mga-class object produced using the 
             GreenGenes v13.8 reference library.")

```

```{r sensitivity, fig.cap = "Boxplot of the phylogenetic diversity of murine gut bacteria in the days immediately following weaning (0-9 days) and months later (141-150 days). Results are compared after evaluating the analysis using three different reference libraries for taxonomic classification."}

# Remove row names from results data frame
div.metrics <- results.df[,c(1:5,27)]
rownames(div.metrics) <- NULL
div.metrics2 <- results.df2[,c(1:5,27)]
rownames(div.metrics2) <- NULL
div.metrics3 <- results.df3[,c(1:5,27)]
rownames(div.metrics3) <- NULL

# Extract diversity indices and dpw group for each ref library
PD.df <- list(Silva_old = div.metrics,
              Silva_new = div.metrics2,
              Greengenes = div.metrics3)

# Add ref libraries
PD.df$Silva_old$ref <- rep("Silva_132", 19)
PD.df$Silva_new$ref <- rep("Silva_138.1", 19)
PD.df$Greengenes$ref <- rep("Greengenes_13.8", 19)

# Collapse into data frame
PD.df <- do.call(rbind, PD.df)
rownames(PD.df) <- NULL # remove row names

# Boxplot of PD across different ref libraries
PD_box <- ggplot(data = PD.df, aes(x = dpwgroup, y = PD)) +
  geom_boxplot(size = 0.5, aes(fill = dpwgroup)) +
  # scale_fill_manual(values = palette3) +
  geom_jitter(shape = 1, width = 0.2) +
  facet_wrap(~ref) +
  labs(fill = NULL, x = "Days Post Weaning", y = "Phylogenetic Diversity") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.title.y = element_text(size = 12, family = "sans", face = "bold",
                                    hjust = 0.5),
        axis.text.y = element_text(size = 10, family = "sans"),
        axis.text.x = element_text(size = 10, family = "sans"),
        axis.title.x = element_text(size = 12, family = "sans", face = "bold",
                                    vjust = 1),
        strip.text = element_text(size = 12, family = "sans"),
        legend.position = "none",
        panel.background = element_blank(),
        panel.border = element_rect(linewidth = 0.2, fill = NA),
        plot.background = element_blank(),
        plot.margin = unit(c(0.2,0.1,0,0.2), "cm")) # top, right, bottom, left
PD_box

```

## Computation Time

To test the how the main `mga()` function performs with regard to the number of samples provided, the computation speed was measured using the `tictoc` package. The outputs were saved and have been re-imported to visualize the run times.

```{r compspeed, eval = FALSE}

# Empty list for storing the results
TICTOC <- list()

comp_time <- list()

# Loop the analysis process 10 times
for (i in 1:10) {

  # Assign metadata to be input as a list
  meta_data <- list()
  for (j in 1:length(fnFs)) {

    ID <- sapply(strsplit(fnFs[i], "_"), `[`, 2)
    ID <- sapply(strsplit(ID, "/"), `[`, 2)
    meta_data[[j]] <- as.list(meta[meta$sample.ID %in% ID,])
  }

  # Add a sample to every new i loop
  Fs <- fnFs[1:i]
  Rs <- fnRs[1:i]
  FFs <- filtFs[1:i]
  FRs <- filtRs[1:i]

  tictoc::tic() # start timer

  # Loop for every file in Fs
  for (n in 1:length(Fs)) {

  # Create a new row of results for each output from the `ps.net`
  TICTOC[[n]] <- mga::mga(fastq.Fs = fnFs[n],
                          fastq.Rs = fnRs[n], # file paths for raw fastq files
                          filtFs = filtFs[n],
                          filtRs = filtRs[n], # file paths for filtered fastq files
                          refFasta = silva.138.1S, # silva ref FASTA with species
                          metadata = meta_data[[j]])
  }

  comp_time[[i]] <- tictoc::toc() # stop timer
}

```

```{r compspeed2, message = FALSE, warning = FALSE, fig.height = 4, fig.width = 4.5, fig.cap = "Scatterplot of processing time for increasing sample sizes from one sample to ten samples."}

# Import saved data
comp_time <- readRDS(file = "vignettes/RDS/comp_time.rds")

# Empty list to store computation times
time.df <- list()

for (i in 1:length(comp_time)) {

  # Extract recorded times
  time.df[[i]] <- c(paste(i), comp_time[[i]]$callback_msg)
}

# Convert list to data frame and reformat
time.df2 <- t(as.data.frame(time.df)) # transpose data frame
time.df2 <- as.data.frame(time.df2)
rownames(time.df2) <- NULL # remove row names
colnames(time.df2) <- c("Samples", "Run_time") # Add column names
time.df2$Run_time <- gsub(" sec elapsed", "", time.df2$Run_time) # remove units
time.df2$Samples <- as.numeric(time.df2$Samples)
time.df2$Samples <- as.factor(time.df2$Samples) # factorize samples (discrete)
time.df2$Run_time <- as.numeric(time.df2$Run_time) # convert run times to numeric

# Plot scatterplot of run time per increase in sample size
time_plot <- ggplot(data = time.df2, aes(x = Samples, y = Run_time)) +
  geom_point(shape = 19, size = 2) +
  labs(x = "No. Samples", y = "Run Time (s)") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.title.y = element_text(size = 10, family = "sans", face = "bold"),
        axis.text.y = element_text(size = 8, family = "sans"),
        axis.text.x = element_text(size = 8, family = "sans"),
        axis.title.x = element_text(size = 10, family = "sans", face = "bold"),
        panel.background = element_blank(),
        panel.border = element_rect(linewidth = 0.2, fill = NA),
        plot.background = element_blank(),
        plot.margin = unit(c(0.2,0.1,0,0.2), "cm")) # top, right, bottom, left
time_plot

```

Based on the figure, computation times show a linear increase. This is preferred over an exponential increase in computation time, however, global parallelization may help reduce the run time of `mga()`, especially for longer steps, such as assigning taxonomy and modelling the phylogenetic tree.

\newpage
## Data Visualization

The Silva v138.1 `mga` outputs are visualized below, first by specifying for the phylogenetic tree with branch tip label modifications, then specifying for the co-occurrence network. The network plot may appear different with each plot, however, although the spacing between individual vertex points changes, the edge lengths joining vertices remains the same.

```{r datavis1, warning = FALSE, message = FALSE, fig.cap = "Phylogenetic tree for sample F3D1 using the Silva v138.1 training FASTA. Branch tip labels, indicating the corresponding ASVs, were  reduced to a quarter of the original size.", fig.height = 4, fig.width = 4.5}

# Plot phylogenetic tree
plot(SILVA.NEWS[[2]], type = "tree", cex = 0.25) # smaller tip label font

```

```{r datavis2, warning = FALSE, message = FALSE, fig.cap = "Phylogenetic tree for sample F3D1 using the Silva v138.1 training FASTA. Branch tip labels were removed for cleaner visualization.", fig.height = 4, fig.width = 4.5}

plot(SILVA.NEWS[[2]], type = "tree", show.tip.label = FALSE) # remove tip labels

```

```{r datavis3, warning = FALSE, message = FALSE, fig.cap = "Co-occurrence network for sample F3D1 using the Silva v138.1 training FASTA. The vertex sizes were adjusted and labels were removed.", fig.height = 3, fig.width = 4}

# Plot co-occurrence network
plot(SILVA.NEWS[[2]], type = "network", point_size = 2, label = NULL)
# remove labels and shrink points

```

\newpage
## Taxonomic Filtering

We used ITS region fungal amplicon data to test the taxonomic filtering function `drop_taxa()`. We performed the analysis on a subset of the data from an unpublished study exploring the soil fungal community of different cover crops and potential impacts on grapevines. The subset used for this test only uses DNA sampled from buckwheat and buffalo grass.

```{r fullfungal1,  fig.cap = "Sequencing quality profiles for the first two reverse sequencing read files, samples F3D0 and F3D1.", fig.width = 6.75, fig.height = 4.5}

# Import ITS fungal reference FASTA
unite.its <- "./vignettes/sh_general_release_dynamic_29.11.2022.fasta"

# Import sample metadata
meta2 <- read.csv("vignettes/Mapping file for ITS sequencing.csv")

# Adjust metadata formatting
colnames(meta2) <- NULL
colnames(meta2) <- meta2[2,]
meta2 <- meta2[-c(1,2),]

# Define filter path for the forward and reverse reads of each sample fastq file
seq_path2 <- "./vignettes/CC_Seq"  # directory for fastq files after extraction from zip

# Sort forward and reverse reads to be in the same order
fnFs2 <- sort(list.files(seq_path2, pattern = "_R1_001.fastq.gz"))
fnRs2 <- sort(list.files(seq_path2, pattern = "_R2_001.fastq.gz"))

# Specify the full path to the fnFs and fnRs
fnFs2 <- file.path(seq_path2, fnFs2)
fnRs2 <- file.path(seq_path2, fnRs2)

# Extract sample names
sNames2 <- sapply(strsplit(fnFs2, "_"), `[`, 2)
sNames2 <- sapply(strsplit(sNames2, "/"), `[`, 2)

# Define file names for filtered fastq.gz files and assign file paths
filt_path2 <- file.path(seq_path2, "filtered")
if (!file_test("-d", filt_path2)) dir.create(filt_path2)
filtFs2 <- file.path(filt_path2, paste0(sNames2, "_F_filt.fastq.gz"))
filtRs2 <- file.path(filt_path2, paste0(sNames2, "_R_filt.fastq.gz"))

# Inspect the first 2 forward reads:
dada2::plotQualityProfile(fnFs2[1:2]) 
# Forward reads maintain high throughput quality, trimmed at position 240

```

```{r fullfungal1B,  fig.cap = "Sequencing quality profiles for the first two reverse sequencing read files, samples F3D0 and F3D1.", fig.width = 6.75, fig.height = 4.5}

# Inspect the first 2 reverse reads:
dada2::plotQualityProfile(fnRs2[1:2])
# Reverse read quality drops at ~position 200, trimmed at position 160
# First 10 bps also removed due to potential pathological issues

```

Above is the code that was used to manually filter files and run the initial analysis for all the sequencing data prior to sampling. The sequencing quality profiles show relatively high throughput quality for both forward and reverse reads, although the reverse read average quality decreases around position 200. The reverse sequence reads were initially trimmed at position 160, however, when revisiting the this analysis ata later time, the trimming position will be adjusted to lengthen to position 200 instead of establishing a cut-off at position 160. Again, the first 10 base pairs were removed from both forward and reverse sequence reads.

```{r fullfungal2, eval = FALSE}

# Filter and trim files based on the previous plots
out2 <- dada2::filterAndTrim(fnFs2, filtFs2, fnRs2, filtRs2,
                            truncLen = c(240,160), # trim positions
                            maxN = 0,
                            maxEE = c(2,2), # 2 errors allowed
                            truncQ = 2,
                            rm.phix = TRUE,
                            compress = TRUE,
                            multithread = FALSE)

```

### `mga` Sequence Processing for Fungal Data

The UNITE General Release ITS FASTA was used as the reference library for taxonomic classification of our fungal sequencing data. Due to the computation time, results were saved and imported for downstream analyses.

```{r fullfungi3, eval = FALSE}

# Empty list for storing the results
UNITE.fungi <- list()

# Loop the analysis process for every file in the directory
for (i in 1:length(fnFs2)){

  # Assign metadata to be input as a list for ps.net argument
  meta_data2 <- list()
  for (j in 1:length(fnFs2)){

    ID2 <- sapply(strsplit(fnFs2[i], "_"), `[`, 2)
    ID2 <- sapply(strsplit(ID2, "/"), `[`, 2)
    meta_data2[[j]] <- as.list(meta2[meta2$`sample-Id` %in% ID2,])
  }

  # Create a new row of results for each output from the `ps.net`
  UNITE.fungi[[i]] <- mga::mga(fastq.Fs = fnFs2[i],
                               fastq.Rs = fnRs2[i], 
                               filtFs = filtFs2[i],
                               filtRs = filtRs2[i], 
                               refFasta = unite.its,
                               metadata = meta_data2[[j]],
                               make.unique = TRUE,
                               tree.args = list(k = 4,
                                                inv = 0.2,
                                                model = "GTR",
                                                rearrangement = "stochastic"),
                               network = TRUE,
                               network.args = list(type = "taxa",
                                                   distance = "jaccard",
                                                   max.dist = 0.35,
                                                   keep.isolates = TRUE))
}

# Extract sample results from the saved list
RES4 <- list()
for (i in 1:length(UNITE.fungi)){

  RES4[[i]] <- UNITE.fungi[[i]]$results.samples
}

# Build combined data frame of metrics
results.df4 <- do.call(rbind, RES4)
# Move sample.ID column to leftmost
results.df4 <- dplyr::relocate(results.df4, "sample.ID", .before = "Shannon")

```

The full dataset was used in sequence processing for a separate study characterizing the soil fungal communities for different cover crop plants. This dataset was subsequently subsetted for the buckwheat and buffalo grass samples to demonstrate taxonomic filtering for select fungal plant pathogens. The subsetted `mga` results were merged using the `merge_phyloseq()` function from the `phyloseq` package to calculate the relative abundance of fungal classes across samples.

```{r Data_wrangling, warning = FALSE, message = FALSE}

# Load fungal data and results
load(file = "vignettes/RDS/unite.its_mga_results.rda")
results.df4 <- readRDS("vignettes/RDS/results.df_unite.its_mga.rds")

# Empty list to store subset data
UNITE <- list()
# Subset list for only buckwheat and buffalo grass samples
for (i in 1:length(UNITE.fungi)) {
  
  if ("Buckwheat" %in% UNITE.fungi[[i]]$sampledata$cover_crop | 
      "Buffalo Grass" %in% UNITE.fungi[[i]]$sampledata$cover_crop) {
    UNITE[[i]] <- UNITE.fungi[[i]]
  }
}

UNITE <- Filter(Negate(is.null), UNITE) # remove null elements in list

# Subset data frame
sub.df <- results.df4[results.df4$cover_crop == "Buckwheat" | 
                        results.df4$cover_crop == "Buffalo Grass",]


## Restructuring data for easier subsequent handling

# Extract all phyloseq objects from UNITE2 into a list
ps.list <- list()
for (i in 1:length(UNITE)) {
  ps.list[[i]] <- UNITE[[i]]$ps
}

# Merge phyloseq OTU tables to return single combined OTU table
ps_C1 <- ps.list[[1]]
# Merging other OTU tables requires a base to add onto
merge.otu <- merge_phyloseq(otu_table(ps_C1)) 

for (i in 1:length(ps.list)) {
  # Extract each phyloseq object from the list
  ps_otu <- ps.list[[i]]
  merge.otu <- merge_phyloseq(otu_table(ps_otu), merge.otu)
}

# Merge taxonomy 
merge.tax <- merge_phyloseq(tax_table(ps_C1))

for (i in 1:length(ps.list)) {
  # Extract each phyloseq object from the list
  ps_otu <- ps.list[[i]]
  merge.tax <- merge_phyloseq(tax_table(ps_otu), merge.tax)
}

# Needed to create the phyloseq-class object
rownames(results.df4) <- results.df4$sample.ID  

# Create a new phyloseq-class object with all combined elements
# `merge_phyloseq()` cannot merge phylogenetic trees with different numbers of tips
merge.ps <- phyloseq(otu_table(merge.otu),
                     tax_table(merge.tax),
                     sample_data(results.df4))

```

A table containing two columns: "taxon" with pathogenic taxon names and "group" with the corresponding taxonomic level was fed into the `drop_taxa()` function as a CSV file to identify potential plant pathogens. The full binomial is used for pathogen names at the species level to avoid mislabeling species with the same species name from different genera.

```{r filtering, message = FALSE, warning = FALSE}

# Import .csv file for taxa to keep
pathogens <- read.csv(file = "vignettes/Plant_Pathogens.csv")
knitr::kable(pathogens, caption = "Pathogenic taxa to filter for in the each 
             `mga-class` object produced.")

```

```{r filtering1, warning = FALSE, message = FALSE, fig.cap = "Phylogenetic tree for sample C11 with all species included."}

# Empty list to store filtered objects
test_filter <- list()
# Filter for pathogens in each `mga` object
for (i in 1:length(UNITE)) {
  test_filter[[i]] <- mga::drop_taxa(UNITE[[i]], taxa = pathogens)
}

# Comparing the phylogeny between filtered and unfiltered
plot(UNITE[[1]], type = "tree", show.tip.label = FALSE)

```

```{r filtering1B, fig.cap = "Phylogenetic tree for sample C11 with only identified pathogens."}

plot(test_filter[[1]], type = "tree", show.tip.label = FALSE)

```

The filtered `mga` results were merged using the `merge_phyloseq()` function to facilitate calculating the relative abundance of fungal classes across samples. 

```{r filtering2, warning = FALSE, message = FALSE}

# Extract filtered sample results from the list
RES5 <- list()
for (i in 1:length(test_filter)){

  RES5[[i]] <- test_filter[[i]]$results.samples
}

# Build combined data frame of metrics
results.df5 <- do.call(rbind, RES5)


## Restructuring data for easier subsequent handling

# Extract all phyloseq objects from `test_filter` into a list
ps.list2 <- list()
for (i in 1:length(test_filter)) {
  ps.list2[[i]] <- test_filter[[i]]$ps
}

# Merge phyloseq OTU tables to return single combined OTU table
ps_C1 <- ps.list2[[1]]
# Merging other OTU tables requires a base to add onto
merge.otu2 <- merge_phyloseq(otu_table(ps_C1)) 

for (i in 1:length(ps.list2)) {
  # Extract each phyloseq object from the list
  ps_otu <- ps.list2[[i]]
  merge.otu2 <- merge_phyloseq(otu_table(ps_otu), merge.otu2)
}

# Merge taxonomy 
merge.tax2 <- merge_phyloseq(tax_table(ps_C1))

for (i in 1:length(ps.list2)) {
  # Extract each phyloseq object from the list
  ps_otu <- ps.list2[[i]]
  merge.tax2 <- merge_phyloseq(tax_table(ps_otu), merge.tax2)
}

# Needed to create the phyloseq-class object
rownames(results.df5) <- results.df5$sample.ID  

# Create a new phyloseq-class object with all combined elements
# `merge_phyloseq()` does not work if phylogenetic trees have different numbers of tips
pathogen.ps <- phyloseq(otu_table(merge.otu2),
                     tax_table(merge.tax2),
                     sample_data(results.df5))

```

The `drop_taxa()` function currently aggregates the `mga` objects by species after the taxonomic filtering step, however, this pruning steps subsequently remove the names of the taxa used to identify the pathogens. Thus, this function will need to be modified for future updates to the package to simplify data visualization. The following code shows the steps needed to add the labelling taxa back to the filtered `mga` object for ease in relative abundance calculations.

```{r filtering2B, warning = FALSE, message = FALSE}

# Extract taxonomy table from filtered `mga` object
pathogen <- as.data.frame(tax_table(pathogen.ps))
spec.names <- pathogen$Species  # save species names
# Rename species column to include the full binomial.
pathogen$Species <- paste(pathogen$Genus, pathogen$Species, sep = " ")

# Search for pathogens in taxonomy table
for (j in 1:nrow(pathogens)) {
  # Search in Family
  if ("Family" %in% pathogens$group[j]){
    for (i in 1:nrow(pathogen)) {
      if (pathogens$taxon[j] %in% pathogen$Family[i]){
        pathogen$keep[i] = 1
        pathogen$keep_taxon[i] = pathogens$taxon[j]
      }}
  # Search in Genus
  } else if ("Genus" %in% pathogens$group[j]){
    for (i in 1:nrow(pathogen)) {
      if (pathogens$taxon[j] %in% pathogen$Genus[i]){
        pathogen$keep[i] = 1
        if (is.na(pathogen$keep_taxon[i])){
        pathogen$keep_taxon[i] = pathogens$taxon[j]
        }}}
  # search in Species
  } else if ("Species" %in% pathogens$group[j]){
    for (i in 1:nrow(pathogen)) {
      if (pathogens$taxon[j] %in% pathogen$Species[i]){
        pathogen$keep[i] = 1
        if (is.na(pathogen$keep_taxon[i])){
          pathogen$keep_taxon[i] = pathogens$taxon[j]
        }}}
  } else {
    pathogen$keep[i] = 0
    pathogen$keep_taxon[i] = NA}
}

# Remove genus from species names
pathogen$Species <- spec.names

# Update the taxonomy table
tax = phyloseq::tax_table(as.matrix(pathogen))
phyloseq::tax_table(pathogen.ps) <- tax

```

### Relative Abundance Bar Plots

The relative abundance of all species aggregated by class was calculated. Fungal classes with abundances >1% were combined into a single category.

```{r allspecies, warning = FALSE, message = FALSE}

# Abundance plots were built following the workflow of Hui (2021):
# https://www.yanh.org/2021/01/01/microbiome-r/#abundance-bar-plot

# Calculate relative taxa abundance
ps.rel <- transform_sample_counts(merge.ps, function(x) x/sum(x)*100)
# Agglomerate samples by taxon of choice
agglomerated <- tax_glom(ps.rel, taxrank = 'Class', NArm = FALSE)
# Melt into data frame
ps.melt <- psmelt(agglomerated)

# Reorder by class and calculate median abundances
ps.melt <- ps.melt %>%
  group_by(Class) %>%
  mutate(median = median(Abundance))

# Identify and combine classes with >1% abundance
rare <- unique(ps.melt$Class[ps.melt$median > 1])
ps.melt$Class[!(ps.melt$Class %in% rare)] <- "< 1%"
# Keep only necessary columns for the bar plot
ps.sum <- ps.melt %>%
  group_by(sample.ID, cover_crop, Class) %>%
  summarise(Abundance = sum(Abundance))  # sum abundances

# How many fungal classes are <1%
other <- ps.melt$Class[!(ps.melt$Class %in% rare)]
length(other)

# Abundance bar plot (Class)
FIG <-
  ggplot(ps.sum, aes(x = sample.ID, y = Abundance, fill = Class)) + 
  geom_bar(stat = "identity", aes(fill = Class)) + 
  labs(x = "", y= "Abundance (%)", tag = "A") +
  facet_wrap(~cover_crop, scales = "free_x", nrow = 1) +
  theme_classic() +
  scale_fill_manual(values = palette) +
  scale_y_continuous(limits = c(0,110), expand = c(0,0)) +
  theme(plot.tag = element_text(size = 14, family = "sans", face = "bold"),
        plot.tag.position = c(0.02, 0.95),
        axis.title = element_text(size = 10, family = "sans", face = "bold"),
        axis.text.y = element_text(size = 8, family = "sans"),
        axis.text.x  = element_text(size = 4, angle = 45, vjust = 0.5),
        axis.line.y = element_line(linewidth = 0.2),
        axis.line.x = element_line(linewidth = 0.2),
        axis.ticks.x = element_line(linewidth = 0.2),
        legend.text = element_text(size = 7, family = "sans", face = "bold"),
        legend.title = element_text(size = 8, family = "sans", face = "bold"),
        legend.key.height = unit(0.32, "cm"),
        legend.key = element_blank(),
        legend.background = element_rect(fill = "transparent"),
        panel.background = element_rect(fill = "transparent"),
        strip.text.x = element_text(size = 8, family = "sans", face = "bold"),
        strip.background = element_blank(),
        strip.placement = "outside",
        panel.spacing = unit(0.15, "lines"),
        plot.background = element_rect(fill = "transparent", color = NA),
        plot.margin = unit(c(0,0.1,0,0.2), "cm")) #top, right, bottom, left

# Load icons for cover crops
buckwheat <- get_phylopic("325ebaf5-9056-4f7c-9e31-5c9a9a82c755")
buffalo <- get_phylopic("461f7280-3636-42c0-98fd-4fca668460c5")

# Plot overlap for cover crop icons
icons <-
  ggplot() +  # empty figure with only cover crop silhouettes
  scale_y_continuous(limits = c(0,100), expand = c(0,0)) +
  scale_x_continuous(limits = c(0,100), expand = c(0,0)) +
  add_phylopic(buckwheat, alpha = 1, x = 23, y = 91, ysize = 8.2, color = "black") +
  add_phylopic(buffalo, alpha = 1, x = 53.8, y = 91, ysize = 8.1, color = "black") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x  = element_blank(),
        axis.line.y = element_blank(),
        axis.line.x = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_rect(fill = "transparent"),
        plot.background = element_blank())

# Layer cover crop icons on top of abundance bar plot
FIG2 <-
  cowplot::ggdraw(FIG) +
  cowplot::draw_plot(icons,
            x = 0,
            y = 0,
            width = 1,
            height = 1)

```

The relative abundances of all pathogenic taxa were calculated.

```{r filtering2C, warning = FALSE, message = FALSE}

# Calculate relative abundance
pathogen.rel <- transform_sample_counts(pathogen.ps, function(x) x/sum(x)*100)
pathogen.melt <- psmelt(pathogen.rel)

# Organize the data for abundance plots
pathogen.melt1 <- pathogen.melt %>%
  group_by(sample.ID, cover_crop, keep_taxon) %>%
  summarise(Abundance = sum(Abundance))  # sum abundances

# Relative abundance bar plot
FIG3 <-
  ggplot(pathogen.melt1, aes(x = sample.ID, y = Abundance, fill = keep_taxon)) + 
  geom_bar(stat = "identity", aes(fill = keep_taxon)) + 
  labs(x = "", y= "Abundance (%)", fill = "Pathogenic Taxon", tag = "B") +
  facet_wrap(~cover_crop, scales = "free_x", nrow = 1) +
  theme_classic() +
  scale_fill_manual(values = palette2) + 
  scale_y_continuous(limits = c(0,110), expand = c(0,0)) +
 theme(plot.tag = element_text(size = 14, family = "sans", face = "bold"),
       plot.tag.position = c(0.02, 0.95),
       axis.title = element_text(size = 10, family = "sans", face = "bold"),
       axis.text.y = element_text(size = 8, family = "sans"),
       axis.text.x  = element_text(size = 4, angle = 45, vjust = 0.5),
       axis.line.y = element_line(linewidth = 0.2),
       axis.line.x = element_line(linewidth = 0.2),
       axis.ticks.x = element_line(linewidth = 0.2),
       legend.text = element_text(size = 6.5, family = "sans", face = "bold"),
       legend.title = element_text(size = 7.5, family = "sans", face = "bold"),
       legend.key.height = unit(0.32, "cm"),
       legend.key = element_blank(),
       legend.margin = margin(0,0,0,0.3, unit = "cm"),
       legend.background = element_rect(fill = "transparent"),
       panel.background = element_rect(fill = "transparent"),
       strip.text.x = element_text(size = 8, family = "sans", face = "bold"),
       strip.background = element_blank(),
       strip.placement = "outside",
       panel.spacing = unit(0.15, "lines"),
       plot.background = element_rect(fill = "transparent", color = NA),
       plot.margin = unit(c(0,0.1,0,0.2), "cm")) #top, right, bottom, left

# Layer cover crop icons on top of abundance bar plot
FIG4 <-
  cowplot::ggdraw(FIG3) +
  cowplot::draw_plot(icons,
            x = 0,
            y = 0,
            width = 1,
            height = 1)

```

To compare the proportion of pathogenic to non-pathogenic species in each sample, the taxonomy table of the unfiltered `mga` object was used to distinguish between pathogenic and non-pathogenic taxa based on the pathogens identified.

```{r filtering3, warning = FALSE, message = FALSE}

# Relative abundance of pathogen to non-pathogenic taxa
# Transform sample counts to relative abundances
ps.species <- tax_glom(merge.ps, taxrank = 'Species', NArm = FALSE)
pathogen.rel2 <- transform_sample_counts(ps.species, function(x) x/sum(x)*100)

# Extract taxonomy table
tax2 <- as.data.frame(tax_table(pathogen.rel2))
# Rename species column to include the full binomial for both taxonomy tables
tax2$Species <- paste(tax2$Genus, tax2$Species, sep = " ")
pathogen$Species <- paste(pathogen$Genus, pathogen$Species, sep = " ")

# Organize the data for abundance plots
tax2$pathogenic <- NA
for (i in 1:nrow(pathogen)) {
  # Identify pathogens
  tax2$pathogenic[tax2$Species == pathogen$Species[i]] <- "Pathogenic"
}

# Label non-pathogenic taxa
tax2$pathogenic[is.na(tax2$pathogenic)] <- "Non-pathogenic"

# Update the taxonomy table
tax2 = phyloseq::tax_table(as.matrix(tax2))
phyloseq::tax_table(pathogen.rel2) <- tax2

pathogen.melt2 <- psmelt(pathogen.rel2) # melt into data frame

# Group by variables needed for bar plot
pathogen.melt2 <- pathogen.melt2 %>%
  group_by(sample.ID, cover_crop, pathogenic) %>%
  summarise(Abundance = sum(Abundance))

# Relative abundance bar plot
FIG5 <-
  ggplot(pathogen.melt2, aes(x = sample.ID, y = Abundance, fill = pathogenic)) + 
  geom_bar(stat = "identity", aes(fill = pathogenic)) + 
  labs(x = "", y= "Abundance (%)", tag = "C") +
  facet_wrap(~cover_crop, scales = "free_x", nrow = 1) +
  theme_classic() +
  scale_fill_manual(values = c("#9EDAFA", "#FD8A8B")) + 
  scale_y_continuous(limits = c(0,110), expand = c(0,0)) +
 theme(plot.tag = element_text(size = 14, family = "sans", face = "bold"),
       plot.tag.position = c(0.02, 0.95),
       axis.title = element_text(size = 10, family = "sans", face = "bold"),
       axis.text.y = element_text(size = 8, family = "sans"),
       axis.text.x  = element_text(size = 4, angle = 45, vjust = 0.5),
       axis.line.y = element_line(linewidth = 0.2),
       axis.line.x = element_line(linewidth = 0.2),
       axis.ticks.x = element_line(linewidth = 0.2),
       legend.text = element_text(size = 6.5, family = "sans", face = "bold"),
       legend.title = element_blank(),
       legend.key.height = unit(0.32, "cm"),
       legend.key = element_blank(),
       legend.margin = margin(0,0,0,0.3, unit = "cm"),
       legend.background = element_rect(fill = "transparent"),
       panel.background = element_rect(fill = "transparent"),
       strip.text.x = element_text(size = 8, family = "sans", face = "bold"),
       strip.background = element_blank(),
       strip.placement = "outside",
       panel.spacing = unit(0.15, "lines"),
       plot.background = element_rect(fill = "transparent", color = NA),
       plot.margin = unit(c(0,0.1,0,0.2), "cm")) #top, right, bottom, left

# Layer cover crop icons on top of abundance bar plot
FIG6 <-
  cowplot::ggdraw(FIG5) +
  cowplot::draw_plot(icons,
                     x = 0,
                     y = 0,
                     width = 1.04,
                     height = 1)

```

```{r filtering4, message = FALSE, warning = FALSE, fig.cap = "(A) Bar plot of the relative abundance of species within each fungal class for buckwheat and buffalo grass samples including all species initially identified. (B) Bar plot of the relative abundance of plant pathogens of interest after pruning for pathogenic fungal taxa. (C) Bar plot comparing the relative abundance of pathogenic to non-pathogenic species.", fig.width = 5, fig.height = 7.5}

# Combine all bar plots
FIG_fin <- cowplot::plot_grid(FIG2, FIG4, FIG6, ncol = 1)
FIG_fin

```

There is significantly more Nectriaceae present in all samples compared to other pathogenic taxa. This can be partially attributed to the Nectriaceae being a higher taxonomic level under which there are many species. The figure comparing the relative number of pathogenic to non-pathogenic species indicates that the `drop_taxa()` function was able to successfully identify the taxa of interest from the provided table. However, improvements can still be made to reduce the amount of post-filtering data wrangling and relabelling of taxa needed to achieve these resulting figures.
